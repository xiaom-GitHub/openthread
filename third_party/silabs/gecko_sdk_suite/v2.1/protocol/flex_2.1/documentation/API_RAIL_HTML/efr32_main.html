<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RAIL: EFR32</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAIL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('efr32_main.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EFR32 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While RAIL attempts to be chip agnostic there are certain hardware differences that can't be overlooked. Where possible, missing features will be simulated in software, but performance characteristics may vary. This section will cover what differs for the EFR32 series of chips as well as any hardware specific configurations or calibrations.</p>
<h2>Packet Buffer Restrictions</h2>
<p>Currently the RAIL library for the EFR32 allocates an internal buffer to store the receive data contiguously. This buffer is set to 512 bytes at build time and cannot be changed. This choice limits the maximum size of receive packets in packet mode and determines the size of the receive FIFO in FIFO mode. Since each receive packet has 6 bytes of overhead this means that you can only receive up to one 506 byte packet without switching to FIFO mode. In FIFO mode you must read out packet data as you approach this limit and store it off to construct the full packet later. Note that this 6 byte overhead may increase or decrease in future releases as we change functionality though we would not expect large jumps in either direction.</p>
<p>The transmit FIFO must be set at runtime with <a class="el" href="group___data___management.html#gaba67c4561ebc027318a70903c9e9daf2">RAIL_SetTxFifo()</a>. Its size must be a power of 2 from 64 to 4096 for hardware compatibility. Note that there is no difference between packet and FIFO mode on the transmit side. A packet may either be loaded all at once or in pieces using the <a class="el" href="group___data___management.html#ga07f5f915afee301566bcef99cfae00c2">RAIL_WriteTxFifo()</a> function. You may also use the <a class="el" href="group___data___management.html#ga1c78ceb2b403a74e597248d27aa44bba">RAIL_SetTxFifoThreshold()</a> function and the <a class="el" href="group___events.html#ga86afb7a7422963a4edd5e0db0228b09f">RAIL_EVENT_TX_FIFO_ALMOST_EMPTY</a> event to load data as there is space available in the FIFO during transmission.</p>
<h2>Data Reception Sources</h2>
<p>When receiving data, you can configure hardware to provide data from three different hardware sources.</p>
<p>First, you can configure the hardware to provide a packet of information. This configuration utilizes the built-in demodulator and frame controller. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a51031cf6cfe1090806bd80081a48febd">RAIL_RxDataSource_t::RX_PACKET_DATA</a> to enable this receive source.</p>
<p>Second, you can configure the hardware to provide data directly from the demodulator. In this mode, the hardware demodulator is used, but the user is responsible for implementing frame controller functionality. (i.e. Preamble detection, sync word detection, CRC validation, etc. must be performed in software by the application.) All data returned is represented as 8-bit 2's-compliment values. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a3680d24c321ca9595f80f4062284de82">RAIL_RxDataSource_t::RX_DEMOD_DATA</a> to enable this receive source.</p>
<p>Third, you can configure the hardware to provide data directly from the I and Q ADCs. In this mode, the user is responsible for implementing demodulator and frame controller functionality. The receive signal hardware has a 19-bit dynamic range, and the user can select whether to return the upper 16 bits of the 19-bit value (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9adfa3e1b96a7fed050c2e5a94c84e5e7a">RAIL_RxDataSource_t::RX_IQDATA_FILTMSB</a>) or the lower 16 bits (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9ad7221f15ed90ababb5aea07e8492a1b1">RAIL_RxDataSource_t::RX_IQDATA_FILTLSB</a>). All data returned is represented as 16-bit 2s-compliment values. The I and Q values are put into the buffer in an alternating fashion where the first 16-bit value is the first I ADC value, and the second 16-bit value is the first Q ADC value, etc.</p>
<h2>Interrupt Vectors</h2>
<p>The RAIL library for EFR32 implements all of the interrupt vectors for radio peripherals. This is required for the RAIL library to function correctly. RAIL does not, however, set the priorities of these interrupt vectors. That must be handled by your application using the CMSIS NVIC_SetPriority() API or direct manipulation of the NVIC. Below is the full list of interrupts used by the radio. You <b>must</b> run them all at the same priority which is what all Silicon Labs RAIL applications do by default. You are free to choose what that priority is based on the requirements of your application (e.g. putting them below FreeRTOS atomic for access to OS functions in RAIL callbacks). Keep in mind that putting the radio interrupts at too low a priority can cause missed packets and other radio performance issues. A restriction on EFR32xG12 and newer is that you must not disable radio interrupts for longer than a quarter of the RAIL timebase (2^32/4 microseconds or 18 minutes) to ensure proper timekeeping. Please see <a class="el" href="group___e_f_r32x_g1x___interrupts.html">EFR32xG1x_Interrupts</a> or follow the links below for more information.</p>
<div class="fragment"><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga5136e4598377244337749247a93f0432">FRC_PRI_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c7a131a40ec0f4f4aedbdad5f15b399">FRC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c462dd15369865c11875a6146538578">MODEM_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gadc2b9acaacd718dcd2e78deacd2b015b">RAC_SEQ_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga20868c2069184ad702beabab4606af73">RAC_RSM_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaf0715f354743cd91d25299840842a730">BUFC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga1381fd3f099f38e273bb091a176fe073">AGC_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaae7189e0f1296a5c53a26a45a2d762ad">PROTIMER_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga7e71cb986f574513f202d02f97a3eb63">SYNTH_IRQHandler</a></div><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga289a52d34c2bbc45e59e4b4c3dc3b958">RFSENSE_IRQHandler</a></div></div><!-- fragment --><h1>Chip Specific Initialization</h1>
<h2>EFR32 Hardware Initialization</h2>
<p>The EFR32 comes with versions of EMLIB and EMDRV to create a basic HAL layer. A lot of this initialization code is completely up to you, but there are a couple of requirements when you're building a RAIL app. Specifically, the radio will only work if you are running off a high precision crystal oscillator. Since some APIs will assume this is running you should make sure to initialize and switch to the crystal before calling any radio APIs.</p>
<p>For the WSTK you can use the crystal configuration in the HAL config header file for your specific kit. Example code for this is shown below. If you have a custom hardware layout you may want to create your own HFXOInit structure to account for things like your specific CTUNE value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bsp.h&quot;</span> <span class="comment">// Contains WSTK versions of the HFXO init structure</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> efrStartup(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_WSTK_DEFAULT;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the HFXO using the settings from the WSTK bspconfig.h</span></div><div class="line">  <span class="comment">// Note: This configures things like the capacitive tuning CTUNE variable</span></div><div class="line">  <span class="comment">//   which can vary based on your hardware design.</span></div><div class="line">  CMU_HFXOInit(&amp;hfxoInit);</div><div class="line"></div><div class="line">  <span class="comment">// Switch HFCLK to HFXO and disable HFRCO</span></div><div class="line">  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);</div><div class="line">  CMU_OscillatorEnable(cmuOsc_HFRCO, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><h2>Radio Specific Initialization</h2>
<p>Currently there are two initialization functions for the radio that depend on your board configuration and must be manually called at startup: <a class="el" href="group___p_a.html#ga457d647ef941d0074c5b0570c252a4dd">RAIL_ConfigTxPower()</a> and <a class="el" href="group___p_t_i.html#gabf0efa0e39d0b3e91aff1da870a9b71a">RAIL_ConfigPti()</a>. You <b>MUST</b> initialize the power amplifier (PA) in order to transmit. You may initialize the packet trace interface (PTI) if you want to use this for debugging.</p>
<h3>Power Amplifier (PA) Initialization</h3>
<p>There are three different PAs available for the EFR32xG1 family of chips: the <a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba2516560d659c6560e761f5611b6e0dba">High Power 2.4GHz PA</a>, the <a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba4389b6e0c999726991d09d66e4a0c57f">Low Power 2.4GHz PA</a>, and the <a class="el" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba6b59de3cb3ac1f64a9eb7e56a311a38d">Sub GHz PA</a>. The specific set of PAs you have available and the supported power levels for those PAs are determined by your part number. Consult the data sheet for more details.</p>
<p>Each PA supports a raw power level value of type <a class="el" href="group___p_a___e_f_r32.html#ga37838bfd8f434aade272985edd3b745d">RAIL_TxPowerLevel_t</a> where a numerically smaller number causes less power to be output from the chip than a higher number. Keep in mind that these values may be capped at the upper and lower ends and do not necessarily map linearly to output power in dBm. To map these values to and from dBm values the RAIL library uses the <a class="el" href="group___p_a.html#ga45369bac87a05c50ca39d31a0dd78ce2">RAIL_ConvertRawToDbm()</a> and <a class="el" href="group___p_a.html#gacdd8ac5181abb15e4f6409a85023c4bf">RAIL_ConvertDbmToRaw()</a> APIs. By default, these use whatever piecewise linear power curves were passed into RAIL_InitTxPowerCurves() to do the conversion. On Silicon Labs boards these curves are included with the board header files. For custom boards this must be measured using test equipment to take into account the differences in the RF path that may exist. In addition for even more custom use cases the conversion functions can be strongly defined in the customer application and provide whatever type of mapping is found to be most effective. Below is an example of using the standard APIs to initialize all PAs on a dual band chip and switch to the 2.4GHz high power PA.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail_8h.html">rail.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail__chip__specific_8h.html">rail_chip_specific.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;plugin/pa-conversion/pa_conversion_efr32.h&quot;</span></div><div class="line"></div><div class="line">RAIL_DECLARE_TX_POWER_VBAT_CURVES(piecewiseSegments, curvesSg, curves24Hp, curves24Lp);</div><div class="line"></div><div class="line"><span class="comment">// Must be called with a valid RAIL_Handle_t returned by RAIL_Init()</span></div><div class="line"><span class="keywordtype">void</span> initPa(<a class="code" href="group___general.html#gade1c256898a301054e34aeee015a3582">RAIL_Handle_t</a> myRailHandle)</div><div class="line">{</div><div class="line">  <span class="comment">// Initialize the RAIL Tx power curves for all PAs on this chip</span></div><div class="line">  RAIL_TxPowerCurvesConfig_t txPowerCurvesConfig = {</div><div class="line">    curves24Hp,</div><div class="line">    curvesSg,</div><div class="line">    curves24Lp,</div><div class="line">    piecewiseSegments</div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span> (RAIL_InitTxPowerCurves(&amp;txPowerCurvesConfig) != <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a9d08f2cf4b5a12507982c72d5b896a02">RAIL_STATUS_NO_ERROR</a>) {</div><div class="line">    <span class="comment">// Could not initialize transmit power curves so something is configured</span></div><div class="line">    <span class="comment">// wrong. Please fix and rebuild.</span></div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Switch to the 2.4GHz HP PA powered off the 1.8V DCDC connection</span></div><div class="line">  <a class="code" href="struct_r_a_i_l___tx_power_config__t.html">RAIL_TxPowerConfig_t</a> railTxPowerConfig = {</div><div class="line">    <a class="code" href="group___p_a___e_f_r32.html#ggaee32825f3105d9af8ef2d9892a6950cba2516560d659c6560e761f5611b6e0dba">RAIL_TX_POWER_MODE_2P4_HP</a>, <span class="comment">// 2.4GHz HP Power Amplifier mode</span></div><div class="line">    1800,                      <span class="comment">// 1.8V vPA voltage for DCDC connection</span></div><div class="line">    10                         <span class="comment">// Desired ramp time in us</span></div><div class="line">  };</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group___p_a.html#ga457d647ef941d0074c5b0570c252a4dd">RAIL_ConfigTxPower</a>(myRailHandle, &amp;railTxPowerConfig)</div><div class="line">      != <a class="code" href="group___general.html#ggae0d330e2daabbf1988161b4bba1ddef3a9d08f2cf4b5a12507982c72d5b896a02">RAIL_STATUS_NO_ERROR</a>) {</div><div class="line">    <span class="comment">// Error: The requested PA could not be selected. Fix your configuration</span></div><div class="line">    <span class="comment">// and try again.</span></div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Set the output power to the maximum supported by this chip</span></div><div class="line">  <a class="code" href="group___p_a.html#ga2e14fc78b4debe690a70888d5a2850c1">RAIL_SetTxPower</a>(myRailHandle, 255);</div><div class="line">}</div></div><!-- fragment --><h3>Packet Trace Interface (PTI) Initialization</h3>
<p>Packet trace on the EFR32 provides a mechanism for viewing transmitted and received radio packets for network sniffing or debugging. It can also be captured by a WSTK and sent to Simplicity Studio for viewing the data in its Network Analyzer tool.</p>
<p>If you want to use this functionality, you must configure what pins you want to use for this output and, optionally how you want to format the data. Note that the WSTK <em>requires</em> the following output format: </p><pre class="fragment">Mode: 8 bit UART mode
Baudrate: 1.6Mbps
Framing Signal: Enabled
</pre><p>If you change anything here it is currently unsupported by the WSTK. In the future we may include support for alternate output modes.</p>
<p>To choose the pins you want you must look in the data sheet for your part and select a valid route location for the FRC_DOUT and FRC_DFRAME signals. These map to PTI.DATA and PTI.FRAME on the WSTK respectively. Once you've found pins that work for your hardware you need to configure the RouteLocation, port, and pin fields in the PTI initialization structure. When using the WSTK for example, you should initialize things as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail_8h.html">rail.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rail__chip__specific_8h.html">rail_chip_specific.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> initPti(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="struct_r_a_i_l___pti_config__t.html">RAIL_PtiConfig_t</a> ptiConfig =   {</div><div class="line">    <a class="code" href="group___p_t_i___e_f_r32.html#gga0076e83c728b4a4416535d3a844dc0e2ad234c120e1441a2620ea81ec8ba86ecf">RAIL_PTI_MODE_UART</a>,     <span class="comment">// Only supported output mode for the WSTK</span></div><div class="line">    1600000,                <span class="comment">// Choose 1.6 Mbps for the WSTK</span></div><div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DOUT</span></div><div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB12</span></div><div class="line">    12,                     <span class="comment">// FRC_DOUT#6 is PB12</span></div><div class="line">    6,                      <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    gpioPortB,              <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    11,                     <span class="comment">// UNUSED IN UART MODE</span></div><div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DFRAME</span></div><div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB13</span></div><div class="line">    13,                     <span class="comment">// FRC_DOUT#6 is PB13</span></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize the Packet Trace Interface (PTI) for the EFR32</span></div><div class="line">  <a class="code" href="group___p_t_i.html#gabf0efa0e39d0b3e91aff1da870a9b71a">RAIL_ConfigPti</a>(<a class="code" href="group___multiprotocol___e_f_r32.html#ga9cc0246bb308ae8311cf0e746c42372e">RAIL_EFR32_HANDLE</a>, &amp;ptiConfig);</div><div class="line"></div><div class="line">  <span class="comment">// Enable Packet Trace (PTI)</span></div><div class="line">  <a class="code" href="group___p_t_i.html#ga75353cc601b04acf7bf55c9d8c53ba91">RAIL_EnablePti</a>(<a class="code" href="group___multiprotocol___e_f_r32.html#ga9cc0246bb308ae8311cf0e746c42372e">RAIL_EFR32_HANDLE</a>, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><h3>Other Radio GPIO Functions</h3>
<p>There are various useful signals related to the radio that can be output on a GPIO using the Peripheral Reflex System (PRS). The PRS is an advanced system where you can route signals to channels and then output those channels to a number of configurable locations. There's a lot more to it than that, so consult the reference manual chapter on the PRS if you want to understand it better.</p>
<p>A list of some of the most interesting PRS signals related to the radio is shown below along with how to enable them in the PRS. The definition for these signals for a given chip can be found in the release at <code>platform/Device/SiliconLabs/&lt;chipFamily&gt;/Include/&lt;chipFamily&gt;_prs_signals.h</code> where <code>&lt;chipFamily&gt;</code> would be the beginning of the part number (EFR32MG12P for example).</p>
<table class="doxtable">
<tr>
<th align="left">Signal </th><th align="left">Summary  </th></tr>
<tr>
<td align="left">PRS_RAC_ACTIVE </td><td align="left">Radio enabled </td></tr>
<tr>
<td align="left">PRS_RAC_TX </td><td align="left">Transmit mode enabled </td></tr>
<tr>
<td align="left">PRS_RAC_RX </td><td align="left">Receive mode enabled </td></tr>
<tr>
<td align="left">PRS_RAC_LNAEN </td><td align="left">LNA enabled for Rx </td></tr>
<tr>
<td align="left">PRS_RAC_PAEN </td><td align="left">PA enabled for Tx </td></tr>
<tr>
<td align="left">PRS_MODEM_FRAMEDET </td><td align="left">Frame detected </td></tr>
<tr>
<td align="left">PRS_MODEM_PREDET </td><td align="left">Preamble detected </td></tr>
<tr>
<td align="left">PRS_MODEM_TIMDET </td><td align="left">Timing detected </td></tr>
<tr>
<td align="left">PRS_MODEM_FRAMESENT </td><td align="left">Frame sent </td></tr>
<tr>
<td align="left">PRS_MODEM_SYNCSENT </td><td align="left">Syncword sent </td></tr>
<tr>
<td align="left">PRS_MODEM_PRESENT </td><td align="left">Preamble sent </td></tr>
</table>
<p>The example below shows you how to configure a PRS channel to output RAC_RX on a GPIO. For this example we assume you're using the WSTK with the BRD4153A radio board. If so, the code below will put RACRX on PRS Channel 0 and output PRS Channel 0 on pin PC10 which is wired to WSTK_P12 and EXP_HEADER15 on the WSTK.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;em_cmu.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_prs.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_gpio.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;em_device.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> enableDebugGpios(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Turn on the PRS and GPIO clocks so we can access their registers</span></div><div class="line">  CMU_ClockEnable(cmuClock_PRS, <span class="keyword">true</span>);</div><div class="line">  CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PC10 as an output</span></div><div class="line">  GPIO_PinModeSet(gpioPortC, 10, gpioModePushPull, 0);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PRS Channel 0 to output RACRX</span></div><div class="line">  PRS_SourceSignalSet(0,</div><div class="line">                      ((PRS_RAC_RX &amp; _PRS_CH_CTRL_SOURCESEL_MASK)</div><div class="line">                       &gt;&gt; _PRS_CH_CTRL_SOURCESEL_SHIFT),</div><div class="line">                      ((PRS_RAC_RX &amp; _PRS_CH_CTRL_SIGSEL_MASK)</div><div class="line">                       &gt;&gt; _PRS_CH_CTRL_SIGSEL_SHIFT),</div><div class="line">                      prsEdgeOff);</div><div class="line"></div><div class="line">  <span class="comment">// Configure PRS Channel 0 to use output location 12 (PC10 - see datasheet)</span></div><div class="line">  PRS-&gt;ROUTELOC0 &amp;= ~_PRS_ROUTELOC0_CH0LOC_MASK;</div><div class="line">  PRS-&gt;ROUTELOC0 |= PRS_ROUTELOC0_CH0LOC_LOC12;</div><div class="line"></div><div class="line">  <span class="comment">// Enable PRS Channel 0</span></div><div class="line">  PRS-&gt;ROUTEPEN |= PRS_ROUTEPEN_CH0PEN;</div><div class="line">}</div></div><!-- fragment --><h2>Required Dependencies</h2>
<p>Most of the RAIL library is self contained, however, there are some dependencies on external functions. Specifically, we rely on functions from the C standard library, EMLIB, and CMSIS. Below is a complete list of these dependencies. If you want to change the implementation of any of these functions while maintaining the functionality that's fine, just know that they could impact RAIL operation.</p>
<table class="doxtable">
<tr>
<th>Group </th><th>Functions  </th></tr>
<tr>
<td>CMSIS </td><td><code>SystemHFXOClockGet()</code><br />
<code>SystemHFClockGet()</code><br />
<code>SystemLFRCOClockGet()</code><br />
<code>SystemLFXOClockGet()</code><br />
<code>SystemULFRCOClockGet()</code> </td></tr>
<tr>
<td>EMLIB (em_cmu) </td><td><code>CMU_ClockEnable</code><br />
<code>CMU_ClockFreqGet</code><br />
<code>CMU_ClockPrescGet</code><br />
<code>CMU_ClockPrescSet</code><br />
<code>CMU_ClockSelectGet</code><br />
<code>CMU_ClockSelectSet</code><br />
<code>CMU_OscillatorEnable</code><br />
 </td></tr>
<tr>
<td>EMLIB (em_gpio) </td><td><code>GPIO_PinModeSet()</code> </td></tr>
<tr>
<td>EMLIB (em_system) </td><td><code>SYSTEM_ChipRevisionGet()</code> </td></tr>
<tr>
<td>EMLIB (em_core) </td><td><code>CORE_EnterCritical()</code><br />
<code>CORE_ExitCritical()</code><br />
<code>CORE_EnterAtomic()</code><br />
<code>CORE_ExitAtomic()</code> </td></tr>
<tr>
<td>EMLIB (em_emu) </td><td><code>EMU_DCDCLnRcoBandSet()</code> </td></tr>
<tr>
<td>stdlib </td><td><code>memcpy()</code><br />
<code>memset()</code> </td></tr>
</table>
<h2>Peripherals Consumed by RAIL</h2>
<p>Currently, RAIL consumes only peripherals that are a part of the radio.</p>
<h3>Future Peripheral Considerations</h3>
<p>In the future, RAIL might use a few of the customer facing peripherals for enhanced functionality. In preparation, below is a list of potential peripherals that could be shared in future RAIL releases.</p>
<ul>
<li>PRS Channels</li>
<li>RTCC Timer</li>
</ul>
<h2>Entropy Generation</h2>
<p>The EFR32 supports true entropy collection using the radio. It is able to collect 1 bit per radio clock cycle while in receive mode. This means that we must enable the receiver when collecting entropy and if you attempt to transmit or otherwise delay entry into receive it will take us a longer time to collect the data. You can still receive packets while collecting entropy and this does mean that requesting random numbers longer than the length of your preamble and sync word may trigger a packet reception. This may be fixed in a future revision but for now this is done to ensure proper packet reception during random data collection.</p>
<p>Due to the nature of random data collection we will always wait for the full amount requested so we should return either the number of bytes requested or zero. Zero is returned if the radio is uninitialized and cannot be enabled for collection.</p>
<h2>RAIL Timebase</h2>
<p>The EFR32 uses a dedicated radio timer to create the RAIL timebase and perform scheduled transmit and receive operations. This timer ticks at roughly every 2us on the EFR32xG1 platform and 0.5us on the EFR32xG12 and newer. The exact tick value depends on the high frequency crystal in use so there may be some small rounding error. All internal APIs account for this error so over long periods of time it is generally unnoticeable. Note that RAIL uses the hardware tick rate to create the 1us time base that is exposed to the user. This is all that should matter for most users and the information here is only to allow you to better understand the underlying implementation.</p>
<h2>Radio Calibration</h2>
<p>The EFR32 supports two radio calibration options: image rejection (IR) calibration and VCO temperature calibration. You may choose to enable one or both of these based upon your specific situation. We always recommend using both for optimal performance of the radio.</p>
<ul>
<li>Image Rejection Calibration (IRCAL)<ul>
<li>This calibration should be run once every time your PHY config changes. It is based on the modulation scheme, frequency band, and other radio settings. RAIL will request this by calling <a class="el" href="struct_r_a_i_l___config__t.html#ac306471283408d4d47ffca784681c740">RAIL_Config_t::eventsCallback</a> with the <a class="el" href="group___events.html#gae37e72673345ce4cd4e4c3ba8abe014a">RAIL_EVENT_CAL_NEEDED</a> bit set and the <a class="el" href="group___calibration___e_f_r32.html#ga97381526c792e093e656130c9a11f12d">RAIL_CAL_ONETIME_IRCAL</a> bit set in <a class="el" href="group___calibration.html#ga1d04d99f4c0e0e82717019fb7735d0b0">RAIL_GetPendingCal()</a>.</li>
<li>Using a proper value for this will improve sensitivity by several dBm, so it's highly recommended.</li>
<li>It can take on the order of 700 ms to complete this calibration. You may want to save off a known good value for this calibration and load it each time you switch PHYs to save time.</li>
<li>This calibration should be initialized before calling <a class="el" href="group___radio___configuration.html#ga19be74a219d6d9271db022b37639c203">RAIL_ConfigChannels()</a> to ensure that it is properly configured by the time the first channel is setup. This initialization involves enabling the algorithm and passing in parameters to configure the algorithm for the specific PHY generated by the EFR32 Radio Configurator.</li>
<li>You cannot use the radio while this calibration is being performed or you may generate an incorrect calibration. Application code should ensure that the radio remains in the idle state during this calibration.</li>
<li>This calibration is only meaningful for Zigbee, BLE, and sub GHz radio configurations. For all others you should still enable the calibration but the algorithm will apply a safe, default calibration value.</li>
</ul>
</li>
<li>VCO Temperature Calibration (VCO_TEMPCAL)<ul>
<li>If you sit in receive for a very long time and experience temperature swings it's possible for the radio to drift off frequency. When this situation is detected RAIL will request this calibration via <a class="el" href="struct_r_a_i_l___config__t.html#ac306471283408d4d47ffca784681c740">RAIL_Config_t::eventsCallback</a> with the <a class="el" href="group___events.html#gae37e72673345ce4cd4e4c3ba8abe014a">RAIL_EVENT_CAL_NEEDED</a> bit set and the <a class="el" href="group___calibration___e_f_r32.html#ga28feea6fbfddfe14e4ba5290b301081d">RAIL_CAL_TEMP_VCO</a> bit set in RAIL_CalPendingGet().</li>
<li>This calibration is automatically run every time we enter receive. So if you are frequently forcing a re-enter into receive mode you may not need to enable this calibration.</li>
<li>On EFR, the application will get this event when the absolute temperature crosses 0C degrees as well as when the temperature delta from the last calibration increases or decreases by 70C.</li>
<li>We always recommend that you enable and handle this calibration since it doesn't add much overhead and is much safer if you ever do end up in this situation.</li>
</ul>
</li>
</ul>
<h2>State Transition Timing</h2>
<p>The EFR32 allows automatic transitions from receive to transmit, in order to precisely time transmitted packets after packet reception. During this process, some internal calculations are done which require the received packet's duration, from sync word to end of CRC, to be less than 32 ms. If some received packets in a given protocol have an on-air time greater than 32 ms, the automatic transition from receive to transmit may not be used with that protocol, as the timing of that transition will be incorrect. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 20 2017 11:32:03 for RAIL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
